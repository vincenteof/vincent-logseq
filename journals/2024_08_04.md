- [[uniswap]] v2 相关数学课程 #[[Crypto Roadmap]]
	- https://updraft.cyfrin.io/courses/uniswap-v2
	- AMM 的核心在于 `x*y=k`，我们假设 `x*y=L^2`
		- 一旦 L 确定，这个池子里所有可能的 x 和 y 的数量就决定了，就是一个反比例曲线上所有的点
		- L 是可以动态变化的，取决于池子被建立时提供的初始流动性，L 越大，曲线会更大且更光滑。对于使用者而言，兑换相同数量的 token 可以得到更多，也就是说价格会更优秀
			- 可以取 L = 200 和 400 的两种例子，计算分别提供 200 个 x 能得到多少个 y
		- 假设池子的当前数量为 x0 和 y0，Alice 将通过 dx 个 x 获得 dy 个 y
			- `x0*y0 = (x + dx)(y - dy)`
			- `dy = (y0 * dx) / (x0 + dx)`
			- 这个公式给出了不含手续费的场景
		- 假设 fee 时 f，0 <= f <= 1, 那么在实际 swap 中的 dx 将变为 (1 -f) * dx
			- `dy = (dx * (1 - f) * y0) / (x0 + dx * (1 - f))`
		- 给定一个 L 会有一个所有代币 x 和 y 的数量曲线，某一个点就是池子的某个状态，这个点的切线的斜率就是这个状态的价格。dx 和 dy 会产生一个兑换率，使 dx 无限小就得到了当前池子的价格。
		- 因为 `dy = (y0 * dx) / (x0 + dx)`，所以 `dy/dx = y0 / (x0 + dx)`，当 dx 无限下，价格就是 y0 / x0。因此如果是小额兑换，执行价格几乎和池子当前的价格是一样的。每一次 swap 的执行价格都会差于池子当前的价格，但好与 swap 执行完以后池子的价格。
		- 这个其实就是 AMM 里的滑点，在订单簿中，当盘口的单子被吃完，价格就会升高。而在 AMM 里，即时是很小的 dx 都会改变曲线上点的位置，类似于盘口的单子被吃完，因此是不能以当前池子的价格完成交易的，只是大部分情况 dx 不是非常巨大的情况导致变化可以忽略不计。
		- 在实际场景中，如果 bob 和 alice 同提交了价格 1 个 ETH 的交易，但是实际执行会有先后，后执行的人滑点总是会更高。
	- mint 和 burn share
	  id:: 672a2ca9-8a71-40f9-a300-60d3ecb1d726
		- 首先考虑比较简单的情况，假设池子里只有一种货币，并且整个池子参与一些生息的活动。每当有人投入资金时，会增发 share，增发的比例应该等同于整个池子价值增加的比例。假设一开始有 1000 USDC 和 1000 个 share，后续生息至 1100 个 USDC。有人投入了 110 USDC，相当于总价值增加了 10%，因此增发 10% 的 share，为 100 个。
			- `S = (L1 - L0) / L0 * T`
		- Burn 也是一样，burn 掉的份额比例应该等同于赎回的代币数量占整个池子的占比
		- 添加流动性导致 AMM 曲线的变动，会变平滑并且对应池子的价格保持不变，说明我们必须按照池子现有比例添加代币，证明的依据是添加了以后在曲线上的点和添加之前的点应该是同一个直线上的
			- 在单个币种的情况下，流动性的定义就等价于该币的数量。在两个币对的情况下，我们需要定移除流动性的定义关于两个币的数量的关系 。f(x, y) = L，有三种方案：
				- f(x, y) = 2 * x
				- f(x, y) = 2 * y
				- f(x, y) = sqrt(x * y)
			- 。。。todo
		- 移除流动性也是一样，移除以后的池子的价格应该和移除以前是一样的，因此也是两种币按照销毁的份额等比例地移除。
	- uniswap 中也存在闪电贷，称之为 flash swap，只要在一比交易中最终把借贷的资金还回去，付出一些手续费就可以获得巨额的资金。
		- 调用流程：
			- FlashSwap 合约会调用 Pair 合约 的 swap 方法，swap 会将资金划转过来，然后调用 FlashSwap 的 `uniswapV2Call` 的回调，调用者需要在这里实现返还资金的逻辑。
		- 只要在调用 Pair 合约的时候传入 data，Pair 合约机会触发调用者的回调，这样就完成了闪电贷的逻辑。`swap` 方法正常调用是在调用前由调用者提前划转想兑换的资金，在执行结束前保证 x*y = k 的 invariant 没有变化。而在闪电贷的情况下，是没有提前划转的资金的，相当于调用者凭空获得了一笔钱，但是需要在 check invaraint 之前把钱还回去，不然交易就会被回滚。
	- uniswap 也可以作为价格预言机，问题在于它的价格是很容易被操控的。
		- 常见的攻击例子：
			- 借贷
		- uniswap 实现了 time weighted average price
			- 时间区间是不均等的，取决于用户调用时间
			- 价格不是连续的而是跳动的，因为每次用户发送交易价就变了
			- TWAP from t0 to tn:
				- 每个累加的价格 pi 乘以一个系数，为 `(ti+1 - ti) / (tn - t0)`
				- 如果时间是从 tk to tn，乘以的系数就变为了 `(ti+1 - ti) / (tn - tk)`
			- 假设我们相识到从 tk to tn 的 TWAP，可以采用记录下每一刻的价格，最终求和的方法。但是 Uniswap 的实现更巧妙，只用了一个状态变量且不需要循环。
				- 首先需要定义 cj = cumulative price up to tj = `sum of dti * pi from 0 to j-1`
				- `sum of dti * pi from k to n-1` becomes `cn - ck`
				- so TWAP from tk to tn = `(cn - ck) / (tn - tk)`
				- 如何获得基于当前时间的 TWAP
				- 1 / TWAP of x != TWAP of y
	- swap 有可能是单跳的，如果存在 x and y 的 pair。如果不存在，Router 会去尝试使用多个 pair 组合起来。这种情况就是多跳的。uniswap v2 的合约分为 core 和 periphery，core 包含了 Pair 和 Factory，Pair 表示每个 token 对，Factory 则永远创建 Pair 并部署。用户一般不会直接和 core 交互，而是和 periphery，其中包含了 Router 合约，用户直接和这个合约交互进行流动性的增减以及币的兑换。
	- v2-perihery 主要是 Router 相关代码
		- `swapExactTokensForTokens` 于 `swapTokensForExactTokens`
		  collapsed:: true
			- 前者输入的 token 是固定的，但是得到的 token 是不固定的。后者则相反，得到的 token 是固定数量的，但输入的 token 是不固定的。
			- 参数里的 path 表示的是 token 合约的地址，用于是表示是单跳的兑换还是多跳的兑换。
			- `getAmountsOut` 与 `getAmountsIn`
				- 用于计算给定的 path 里每一步兑换得到的金额
				- 以 `getAmountsOut` 为例，会根据 path 的长度构造返回的 amounts 数组，第 0 项放入 `amountIn`, 后续每一步的金融都根据 path 里相邻的两项的 reverse 计算得到 token 数量，并放入 amounts 中，这里又会调用计算单跳兑换金额的函数 `getAmountOut`。
					- `getAmountOut` 的计算为
					  ```solidity
					  uint amountInWithFee = amountIn.mul(997);
					  uint numerator = amountInWithFee.mul(reserveOut);
					  uint denominator = reserveIn.mul(1000).add(amountInWithFee);
					  amountOut = numerator / denominator;
					  ```
					- 简化一下就是 ain * 997 * rout / rin * 1000 + ain * 997
						- 上下同时除以 1000 得到 ain * 0.997 * rout / rin + ain * 0.997
						- 其实就是 `(y0 * dx) / (x0 + dx)`
			- 最终会调用 `_swap` 函数，它的入参为 `_swap(uint[] memory amounts, address[] memory path, address _to)`
				- 一个例子：[100, 200, 300], [ETH address, DAI address, MKR address], addr0
				- 由于每个 Pair 在构造的时候都有 token0 和 token1, 后续的 swap 的参数顺序也是根据 token0 和 token1 决定的。因此在我们虽然知道第一步要从 ETH 向 DAI 兑换，但是我们并不知这两个币种哪个是 token0，因此我们需要 sort 后判断来决定传入 swap 的参数。
				- `address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;`
					- 中间步骤的转账地址需要寻找对应池子的地址，最后一步是到给到 swap 的调用者，因此直接取 to 即可
				- 下面就是 v2-core 里的 Pair 相关的 swap 逻辑，调用时会传入想获得的 token0 和 token1 的数量。注意到在兑换之前，相关的 token 就已经被划转到了 Pair 合约里。划转的是 token0，那么传入的 token0 数量就是 0，只有想获得的 token1 的数量。
		- `addLiquidity`
			- 会调用内部的 `_addLiquidity`，这个方法会最终返回应该向池子添加两种代币数量。因为池子是在不断变动的，因为需要这个去计算当下应该添加多少。如果当前池子不存在的话，会调用 Factory 的 `createPair`。首先会先获取 Pair 里的 reserve，如果没有，那么可以直接添加用户指定的 token 数量。如果存在，就需要按照当前的池子的比例去匹配。先尝试匹配amountADesired 计算 B 需要多少，如果落在期望区间里，就直接返回。如果不满足，再以 amountBDesired 为基准去计算需要 A 的数量。如果都不满足直接抛出错误。
			- 计算去需要的 A 和 B 数量，先从用户划转到对应 Pair，最后调用 Pair 的 mint 生成 LP token 返回用户。
		- `removeLiquidity`
			- 首先根据币对找到 Pair，然好把要销毁的流动性划转给 Pair。调用 Pair 的 `burn` 方法拿到对应的两种币的数量，和预期最小比对，如果满足要求就算成功。
	- v2-core 里主要是 Pair 和 Factory
		- Factory
			- `createPair` 会创建币对，首先需要先排序，因为底层的 swap 方法需要传入对应 token0 和 token1 的数量，创建时排序好对外界而言就确定了。这里利用 create2 去部署合约，这样可以让部署的合约的地址是确定的，外部也可以根据 token0 和 token1 去找到对应的 Pair 地址，因为用户直接和 Router 打交道，Router 需要找到对应的 Pair。Pair 合约的 consturctor 没有参数，需要部署后手动 initialize，因为改变 constructor 参数会改变 creationCode，为地址计算带来了不确定性。
		- Pair
			- `swap` 接受两个参数，分别表示 token0 和 token1 需要划转出去的代币数量，这个是由上上层的计算出来的，函数内部校验很宽松，只要满嘴 x*y = k 依然被满足即可
				- 因为这个函数里只有兑换出去代币的数量，没有进入的数量，因为需要通过 ERC20 代币的 balance 去计算
					- `uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;`
					- 因为当执行这个函数时，调用者因为把输入的代币划转进入了 Pair 的合约，因为 balance 就是最新值，而 reverse 是上一个状态的值，因此只要相减就能得到输入的代币数量
					- 输入的代币数量将被收取 3% 的手续费，这里的 balanceAdjust 就是去除了手续费之后的余额
					- `require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');`
					- 只要 x*y > k, 就说明协议没有吃亏，视为 variant 没有改变
			- `mint` 因为流动性添加的代币在调用这个合约前已经被划转，因此需要用 ERC20 的 balance 减去上次的 reserve 来获得新添加的数量。
				- `mintFee` 参见白皮书
				- 区分是否是首次添加流动性。这里的流动性计算方案用了 `sqrt(x*y)`。如果是首次添加，会将很小的一部分永远锁定住，防止通胀攻击。如果不是，就按照划转进来 token 的比例，不论是按 A 算还是按 B 算应该都是一样，计算对应的增发的 LP token。
				- 将计算出的流动性对应的 LP token 划转给目标地址同时更新 Pair 内部的 reverse。
			- `burn` 的流程于 `mint` 类似且更简单，因为需要区分是否首次，直接按照销毁的流动性数量与总的占比分别计算出需要返回给调用者的两个币的数量并进行划转。
			- `_update` 用于更新合约内部的余额状态，`mint`，`burn` 及 `swap` 都会调用。其中还有一个核心功能是记录 cumulative price。因为 solidity 里没有浮点数，因此用到 UQ112 模拟，224位的一半表示整数，一半表示小数，因为原生没有浮点数，因此具体的数值展示需要链下处理。
				- 这里
			-
- [[zk]]相关课程
	- https://www.youtube.com/watch?v=-2qHqfqPeR8&list=PLvvyxOd1rILerZHAs52Z36fyBBK1HHP8b