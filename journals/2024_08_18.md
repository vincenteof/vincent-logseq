- smart contract programmer 关于 [[tornado cash]] 的解释 #[[Crypto Roadmap]]
	- {{video https://www.youtube.com/watch?v=z_cRicXX1jI}}
	- 用户在存入 1 个 ether 的时候需要同时提交一个 commitment，commitment 的计算方式为
		- `hash(secret, nullifier)`
		- secret 是用户生成的用于标识身份
		- nullifier 用于阻止双花
	- 为什么大家都要存入 1 个 ether
		- 因为如果有人存入了比如 231 个 ether，他向对于别人是特立独行的，那个在提币的时候就会被别人注意到
		- tornado 实际上针对不同的金额有多个 merkle tree，比如 0.1 ETH，1 ETH，10 ETH
	- 提款的时候能否直接提交 secret 和 nullifier 然后合约通过 `hash(secret, nullifier)` 去查找之前的存款并划转？
		- 不能，因为一旦提交了这个，因为区块链的透明性，别人也可以根据相同的运算规则，找到之前存入的地址
		- 解决方案是提交 `我知道一对 (secret, nullifier) 最终可计算出 hash(secret, nullifier) 为某个 commitment` 的 proof
		- tornado cash 使用的 zkp 方案成为 zk-SNARK
	- 用户能否使用同一个 proof 多次提取
		- 不可以，对应的 proof 会检查两件事
			- h(s, n) in the bucket
			- h(n) = n
		- 一旦用户提取完成以后，智能合约内会存储 h(n) 已被使用
	- 用户的 commitment 时如何存储在在合约的
		- 通过 merkle tree 存储
		- 每个 `c = h(s, n)` 被存储在 tree 的 leaf 里
	- 如何证明一个 commitment 在 tree 里
		- 提供所有组成最终 root hash 的其他 hash (merkle path)
- 更细节的讲述 [[tornado cash]] 的视频教程 #[[Crypto Roadmap]]
	- {{video https://www.youtube.com/watch?v=VtUOPUZ1qy8}}
	- tornado 里的 merkle tree
		- 叶子结点的数量是固定，一旦满了会部署新树
		- 树上的每个节点都有默认值，不同层级不一样，tornadao cash 的合约代码里硬编码了这个
		- 每次插入会针对一个 index，标识下一个叶子结点的位置，插入完成后需要更新 merkle path 上的所有 hash。完成以后 index 变为下个 sibling
		- 计算一连串 hash 的时候注意指针的移动规则
		- tornado cash 存储的 merkle root 数量是有限制的，超过了会开始覆盖前面的。因为一个 merkle tree 存储的 commitment 是有限的，超过就会到下一棵树上。
		-
	-