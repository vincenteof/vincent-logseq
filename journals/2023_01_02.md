- challenging [[algorithms]] and [[data structures]] every programmer should try #TechDirections
	- https://austinhenley.com/blog/challengingalgorithms.html
- [[Functional Reactive Programming]] 与 [[temporal logic]] 之间的关联，用 [[haskell]] 描述 #TechDirections
- [[PL]] courses by [[rescript]] author #TechDirections
	- https://twitter.com/bobzhang1988/status/1609421898726928385
	- https://www.youtube.com/playlist?list=PLjCFD-dfoL3Ati_SARbhTltV4MY-iClfq
- [[SSH]] 实用技巧  #TechDirections
	- https://iximiuz.com/en/posts/ssh-tunnels/
	- https://plantegg.github.io/2019/06/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8_SSH_%E6%9A%97%E9%BB%91%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3--%E6%94%B6%E8%97%8F%E4%BF%9D%E5%B9%B3%E5%AE%89/
	- 原作者还写了 [[computer networking]] 的一个 series
		- https://iximiuz.com/en/series/computer-networking-fundamentals/
- [[useEffect]] more like useFootgun amirite  #TechDirections
	- https://twitter.com/cpojer/status/1609357205903638528
- [[react-query]] v3 版本由于将状态存储至外部对象，因此在 react18 版本下会造成 tearing，需要通过 [[useSyncExternalStore]] 解决 #TechThoughts
	- https://blog.saeloun.com/2021/12/30/react-18-usesyncexternalstore-api
	- https://juejin.cn/post/7169515109172609032
	- https://tkdodo.eu/blog/2022-in-review#v3-and-react-18
- use [[git]] [[rebase]] in real life  #TechDirections
	- https://about.gitlab.com/blog/2022/11/08/rebase-in-real-life/?utm_campaign=blog&utm_medium=social&utm_source=twitter
	- https://about.gitlab.com/blog/2022/10/06/take-advantage-of-git-rebase/
- LATER [[signal]] in [[preact]]，其实就是把 [[observable]] + [[context]] 这套流程标准化了？在 [[react]] 中搭配 [[mobx]] 或者 [[rxjs]] 也可以做到类似的语意？它与 solid.js 的 [[signal]] 有啥区别？ #TechDirections #TechThoughts
	- https://twitter.com/robmclarty/status/1609023492649029633
	- https://t.co/rrNHM34vSq
	- [[preact]] 引入 [[signal]] 的目的主要是因为之前的状态管理方案都不 scale。原生的状态管理机制主要有两种：
	  1. 将公共 state 提取到公共的祖先，但随着应用的复杂程度提升，最终大部分状态都变成了全局状态。或者说单个保存状态祖先下面有大量的子节点。为了避免祖先更新子组件全部重新渲染，需要大量的 useMemo。但是当 codebase 变得足够庞大，人工枚举依赖项的心智包袱巨大，不稳定的依赖项难以追溯。
	  2. 第二种模式是 context。我们将独立的状态拆分到不同的 context 里面，这样只有订阅 context 的组件会 rerender。但是如果在庞大的树形结构中，如果一个中间节点同时依赖多个 context，那么会导致这个节点的子节点有更大的几率全量 rerender。解决方案又回到了大量的 useMemo，和上面一样的情形。
- LATER [[webpack]] 是如何处理 es6 module 的？默认引入一个 package.json 里写明 type: "module" 的包 resolve 报错：
	- https://github.com/travist/jsencrypt
	- probably because the origin is strict EcmaScript Module, e. g. a module with javascript mimetype, a '*.mjs' file, or a '*.js' file where the package.json contains '"type": "module"'
	- https://github.com/travist/jsencrypt/issues/270
-