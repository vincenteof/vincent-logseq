- [[tornado cash]] 代码分析 #[[Crypto Roadmap]]
	- 关于其中用到的 zkp 相关知识，可以参考这里
		- https://docs.circom.io/background/background/
	- 整个智能合约的核心代码在一下几个文件：`MerkleTreeWithHistory`, `Tornado`, `Verifier`。基于 `Tornado` 又派生出了 `ETHTornado` 以及 `ERC20Tornado` 分别处理 ether 以及其他 ERC20 代币的混淆。
	- `MerkleTreeWithHistory` 是最底层存储的实现
		- 作为 merkle tree，hash function 没用原生提供的 keccak256，需要外部传入对应的 hasher，这里需要使用 MiMC hash function，因为它在和 zkp 一起使用时比较有效。
		- `_insert` 包含了插入一个结点的核心逻辑，`nextIndex` 存储了下一个插入结点的位置，插入逻辑就根据它是奇数还是偶数来判断当前插入的是左结点还是右结点
			- ```solidity
			  for (uint32 i = 0; i < levels; i++) {
			  	if (currentIndex % 2 == 0) {
			      	left = currentLevelHash;
			          right = zeros(i);
			          filledSubtrees[i] = currentLevelHash;
			      } else {
			      	left = filledSubtrees[i];
			          right = currentLevelHash;
			      }
			      currentLevelHash = hashLeftRight(hasher, left, right);
			      currentIndex /= 2;
			  }
			  ```
			- 当插入一个结点时，每一层上的某个 hash 都需要更新（merkle path）。 `filledSubtrees` 存储了每一个 level 上最右边的元素。
				- 思考为什么这种操作下成立？
			- 每次插入完一个元素，root hash 都会改变。`roots` 记录了 root hash 的历史，`currentRootIndex` 记录了当前 root hash 的 index。在代码实现中最多会保留 30 个历史，因此插入完成以后更新 `currentRootIndex` 需要取余。
				- 思考保留 30 个会不会导致提款丢失？
			- `zeros` 函数是根据预先定义的 `ZERO_VALUE` 计算出的每一级以及根的 hash，用来表示未被初始化的状态。对于 level 0 而言，一共 2 ^32 个 个结点的初始值都是 zeros(0)。由于 level 0 的每个初始值是一样的，导致 level 1 上每个结点的初始值也是一样的，一共 2 ^ 31 个结点初始值都是 zeros(1）
				- 这里类似于哨兵值，如何保证实际提交的值不会和这个重复？
		- `isKnownRoot` 用于判断一个 root hash 是否是近 30 个历史之一，利用环形数组的性质去遍历
		- `getLastRoot` 获取当前的 root hash
	-