- 比特币实验了用区块链作为分布式共识的底层工具，但是它无法解决所有复杂的链上需求。
- 以太坊提供了图灵完备的编程语言去实现智能合约来满足这个需求。
- 比特币提出的 Proof-of-Work (POW) 同时解决了两个问题：
	- 1. 提出了一个简单有效的共识算法，基于它网络中的节点可以对比特币账本的更新状态达成一致。
	  2. 提供了一种参与共识过程的准入机制，解决了谁能影响共识这个政治问题并且防范了女巫攻击。
	- 比特币替换掉了之前的一些方案用基于类似白名单机制去建立节点的参与壁垒，取而代之的是直接用节点算力这种经济壁垒去决定投票者的权重。
	- 因此，有另一种称之为 Proof-of-State (POS) 的方法，它用节点持有的代币数量去决定权重，而不是 POW 指定的计算资源。
	- 这两种方法奠定了加密货币的基石。
- 比特币的账本可以视作一种状态转换系统，状态是所有已经存在的比特币的从属关系，状态转换函数则基于当前状态以及交易生成一个新的状态。
	- `APPLY(S,TX) -> S' or ERROR`
	- 比特币里的状态是所有已经被挖出但未被消费的币，更严格的说是所有 ‘未被消费的交易输出’ （"unspent transaction outputs" or UTXO）
	- 所有的 UTXO 都有一个面值及一个拥有者（一串共钥）
	- 每一笔交易有一个或多个指向 UTXO 的输入，以及一个币的拥有者私钥生成的签名，交易会产生一个或多个输出，这些输出形成新的 UTXO，整个比特币账本状态也发生了更新。
	- `APPLY(S,TX) -> S' or ERROR`
		- 对 TX 的中的每个输入，
			- UTXO 不在 S 中则直接错误
			- 提供的签名无法被验证是 UTXO 的拥有者，直接错误
		- 所有输入 UTXO 的面值总和小于输出 UTXO 的面值总和，直接错误
		- 返回的新的 S 中所有输入的 UTXO 删除，输出的 UTXO 添加
	- 一个例子：
		- 假设 Alice 需要转 11.7 个 BTC 给 Bob，首先需要查找属于 Alice 的 UTXO 凑到这个数字，很有可能不能正好找到这么多，那么需要找到一个最小值，比如 6 + 4 +2 = 12 个 BTC。那么这比交易将以这三个 UTXO 作为输入，然后产生两个新的 UTXO 作为输出，一个是给 Bob 的 11.7 个 BTC，另外一个是 0.3 BTC 的找零。
-
- 参考：
	- https://ethereum.org/en/whitepaper/