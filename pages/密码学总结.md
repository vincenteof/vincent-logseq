- 密码学的核心：
- 1. 私钥 k 的建立
  2. 基于 k 去保障通信安全（攻击者无法破解且无法篡改）
-
- 密码学的其他功能
- 1. 电子签名（digital signature）
  2. 匿名通信
  3. 匿名的数字货币 （如何保障匿名性？如何防止双花）
-
- 还有一些 case，比如选举和拍卖，这种情况我只想暴露出一个最终的结果而不想透露出其他信息。抽象一下这个行为，在整个行为中会有 n 个参与者，x1 ... xn，目标是要计算一个结果 f(x1, x2, ... , xn)，如果不泄露任何一个输入？
- 最简单就是引入一个中心化的信任机构，让它去做计算。然而任何可以依靠 trusted auth 完成的事都可以 done without trusted auth。通过引入一些协议，让参与这依据协议交流，可以得到最终结果且不暴露每个输入。
-
- 其他 crypto magic
- privately sourcing computation：
  加密后的搜索条件传给类似 google 的系统，google 可以根据这个条件把该筛选条件的加密后的搜索结果返回给你，你可以解密出来，这个过程里 google 并不知道你搜索了什么。
- zero knowledge：
  假设你知道如何将一个大质数 N 分解为 p * q，你如何在不透露 p 与 q 的情况下向他人证明你知道这一点
-
- 密码学的三个思维步骤
- 1. 对于任何一个 cryoto primitive，定义出威胁模型
  2. 提出构造方案
  3. 证明任何可以 break 构造方案的方法都等价于解决一些几乎无解的问题
-
- 一些历史：
- 对称加密：加密与解密使用同一个密钥 k
- 一些被广泛破解的例子：
	- 替换加密，k 是一组字母的映射关系，别人知道算法也不一定能破解，因为不知道 k
	- 凯撒加密，对字母做移位，这种情况下没有 k，只要别人知道算法如何工作就能破解
	- vigener cipher，将 k 扩展到和密文 m 一样长。然后把每一位的 k 和 m 相加得到结果，揭秘就是相减
	- rotor machines，本质上还是替换加密，但每次输入一个字符后，映射规则就会发生改变，
	- 现今的标准，des（key space 太小，已经可以被破解），aes，salsa20, ...
- 替换加密的 key space：
	- 一个 26 个位置，第一个位置可以取 26 种可能，第二个位置可以取 25 种 ... -> 26!
	- 尽管空间很大，但是这个方法依然很不安全
	- 我们可以使用字母出现的频度表，标准英语中出现做多的是 “e”，“t”，“a”，利用频度百分比我们可以大致找到这三个字母的对应关系，剩下的字母出现频率都差不多
	- 接下去我们可以适应两位的字母，比如 “he”，“an”， “th”，三位的，四位的...
	- 这种方式不安全的根本原因是很容易通过密文获取密钥
- 破解 vigener cipher：
	- 首先假设我么知道 k 的长度，我们按照这个长度对 m 分组，对于每个组中的第一位，假设第一位出现最多的是 “h”，那么 “h” 就很有可能代表 “e”，“h” - “e” 就得到了 k 的第一位，按照这种方法可以对每一组的每一位做操作。想要完全破解，只要遍历 k 的长度，知道得到 m 有意义的解释即可。（分组之后的假设是否成立？）
- 貌似大多数破解都依赖于频率分布？
-
-
- 加密算法正确性依赖于离散概率：
- U: 一个有穷集合，例如 U={0,1}^n （n 位长的 0，1 串）
- 概率分布 P over U 是一个函数
	- P: U -> [0, 1]
	- sum [P(x), x in U] == 1
- 概率分布几个例子：
	- 均匀分布：P(x) = 1 / | U |
	- 点分布：某个点上的概率为 1，其余都是 0
- 分布向量：
	- (P(00), P(01), P(10), P(11))
- 事件：
	- U 上的一个子集 A，Pr[A] = sum [P(x), x in A]，Pr 的结果范围在 [0, 1]，Pr[U] = 1
	- 集合 A 就称为一个事件
	- 例子：
		- U = {0,1}^8  | U | = 256
		- A = [ x | x in U, lsb2 x == 11] 最低两位是 11
		- Pr[A] = 1 / 4 （2^6 / 2^8）
	- 联合界（union bound）：
		- 对于事件 A1 与 A2
			- Pr[A1 U A2] <= Pr[A1] + Pr[A2]
			- 想象一个维恩图，A1 与 A2 有可能会有交集，因此这个概率必然小与单个概率的和，因为重复的部分需要去除
			- 如果两者没有交集，这个概率等于两个概率的和
	- 随机变量（random variables）：
		- 随机变量 X 是一个函数，把全集 U 映射到另一个集合 V
		- 例子：
			- U = {0,1}^n
			- V = {0,1}
			- X(y) = lsb(y)
			- 给 X 一个长度为 n 的 01 子串，改子串的最低位是 {0,1}
			- 对于 U 上的平均分布 Pr
			- Pr[X=0] = 1/2
			- Pr[X=1] = 1/2
			- 最低位是 0 或 1 的概率都是 1/2
		- more general：
			- Pr[X=v]=Pr[rev . X v]
			- rev . X 是 X 的反函数
	- 均匀随机变量（uniform random variable）:
		- U 是 {0,1}^n
		- r 是 U 上一个均匀随机变量
		- 对于任意一个 U 中的元素 a
			- Pr[r=a] = 1 / |U|
		- 假设 r 是一个 {0,1}^2 上的随机分布
			- 随机变量 X = r1 + r2
			- 那么 Pr[X=2] = 1/4
			- 因为 Pr[X=2] = Pr[r=11] = 1/4
	- 随机化算法（randomized algorithms）：
		- 对于确定性算法，一个输入 m 总能得到一个不变的输出 A(m)
		- 随机化算法则每次会有一个附带参数 r，r shi
-
-
-
-
-
-