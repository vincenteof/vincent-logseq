- 密码学的核心：
- 1. 私钥 k 的建立
  2. 基于 k 去保障通信安全（攻击者无法破解且无法篡改）
-
- 密码学的其他功能
- 1. 电子签名（digital signature）
  2. 匿名通信
  3. 匿名的数字货币 （如何保障匿名性？如何防止双花）
-
- 还有一些 case，比如选举和拍卖，这种情况我只想暴露出一个最终的结果而不想透露出其他信息。抽象一下这个行为，在整个行为中会有 n 个参与者，x1 ... xn，目标是要计算一个结果 f(x1, x2, ... , xn)，如果不泄露任何一个输入？
- 最简单就是引入一个中心化的信任机构，让它去做计算。然而任何可以依靠 trusted auth 完成的事都可以 done without trusted auth。通过引入一些协议，让参与这依据协议交流，可以得到最终结果且不暴露每个输入。
-
- 其他 crypto magic
- privately sourcing computation：
  加密后的搜索条件传给类似 google 的系统，google 可以根据这个条件把该筛选条件的加密后的搜索结果返回给你，你可以解密出来，这个过程里 google 并不知道你搜索了什么。
- zero knowledge：
  假设你知道如何将一个大质数 N 分解为 p * q，你如何在不透露 p 与 q 的情况下向他人证明你知道这一点
-
- 密码学的三个思维步骤
- 1. 对于任何一个 cryoto primitive，定义出威胁模型
  2. 提出构造方案
  3. 证明任何可以 break 构造方案的方法都等价于解决一些几乎无解的问题
-
- 一些历史：
- 对称加密：加密与解密使用同一个密钥 k
- 一些被广泛破解的例子：
	- 替换加密，k 是一组字母的映射关系，别人知道算法也不一定能破解，因为不知道 k
	- 凯撒加密，对字母做移位，这种情况下没有 k，只要别人知道算法如何工作就能破解
	- vigener cipher，将 k 扩展到和密文 m 一样长。然后把每一位的 k 和 m 相加得到结果，揭秘就是相减
	- rotor machines，本质上还是替换加密，但每次输入一个字符后，映射规则就会发生改变，
	- 现今的标准，des（key space 太小，已经可以被破解），aes，salsa20, ...
- 替换加密的 key space：
	- 一个 26 个位置，第一个位置可以取 26 种可能，第二个位置可以取 25 种 ... -> 26!
	- 尽管空间很大，但是这个方法依然很不安全
	- 我们可以使用字母出现的频度表，标准英语中出现做多的是 “e”，“t”，“a”，利用频度百分比我们可以大致找到这三个字母的对应关系，剩下的字母出现频率都差不多
	- 接下去我们可以适应两位的字母，比如 “he”，“an”， “th”，三位的，四位的...
	- 这种方式不安全的根本原因是很容易通过密文获取密钥
- 破解 vigener cipher：
	- 首先假设我么知道 k 的长度，我们按照这个长度对 m 分组，对于每个组中的第一位，假设第一位出现最多的是 “h”，那么 “h” 就很有可能代表 “e”，“h” - “e” 就得到了 k 的第一位，按照这种方法可以对每一组的每一位做操作。想要完全破解，只要遍历 k 的长度，知道得到 m 有意义的解释即可。（分组之后的假设是否成立？）
- 貌似大多数破解都依赖于频率分布？
-
-
- 加密算法正确性依赖于离散概率：
- U: 一个有穷集合，例如 U={0,1}^n （n 位长的 0，1 串）
- 概率分布 P over U 是一个函数
	- P: U -> [0, 1]
	- sum [P(x), x in U] == 1
- 概率分布几个例子：
	- 均匀分布：P(x) = 1 / | U |
	- 点分布：某个点上的概率为 1，其余都是 0
- 分布向量：
	- (P(00), P(01), P(10), P(11))
- 事件：
	- U 上的一个子集 A，Pr[A] = sum [P(x), x in A]，Pr 的结果范围在 [0, 1]，Pr[U] = 1
	- 集合 A 就称为一个事件
	- 例子：
		- U = {0,1}^8  | U | = 256
		- A = [ x | x in U, lsb2 x == 11] 最低两位是 11
		- Pr[A] = 1 / 4 （2^6 / 2^8）
	- 联合界（union bound）：
		- 对于事件 A1 与 A2
			- Pr[A1 U A2] <= Pr[A1] + Pr[A2]
			- 想象一个维恩图，A1 与 A2 有可能会有交集，因此这个概率必然小与单个概率的和，因为重复的部分需要去除
			- 如果两者没有交集，这个概率等于两个概率的和
	- 随机变量（random variables）：
		- 随机变量 X 是一个函数，把全集 U 映射到另一个集合 V
		- 例子：
			- U = {0,1}^n
			- V = {0,1}
			- X(y) = lsb(y)
			- 给 X 一个长度为 n 的 01 子串，该子串的最低位是 {0,1}
			- 对于 U 上的平均分布 Pr
			- Pr[X=0] = 1/2
			- Pr[X=1] = 1/2
			- 最低位是 0 或 1 的概率都是 1/2
		- more general：
			- Pr[X=v]=Pr[rev . X v]
			- rev . X 是 X 的反函数
	- 均匀随机变量（uniform random variable）:
		- U 是 {0,1}^n
		- r 是 U 上一个均匀随机变量
		- 对于任意一个 U 中的元素 a
			- Pr[r=a] = 1 / |U|
		- 假设 r 是一个 {0,1}^2 上的随机分布
			- 随机变量 X = r1 + r2
			- 那么 Pr[X=2] = 1/4
			- 因为 Pr[X=2] = Pr[r=11] = 1/4
		- 它说明的是 U 里的每个元素都是均匀的发生
	- 随机化算法（randomized algorithms）：
		- 对于确定性算法，一个输入 m 总能得到一个不变的输出 A(m)
		- 随机化算法则每次会有一个附带参数 r，r 满足 {0,1}^n 上的一个随机分布
		- A(m; r) 的输出是一个随机变量，把 m 所有的取值映射到了 A(m; r)  上
		- 例如：
			- A(m; k) = E(k, m)
			- 对 m 用 k 做加密
			- 它是一个随机变量，这个随机变量的取值范围是 m 所有可能的密文
-
-
- 独立性：
	- 事件 A 和 B 是独立的，如果
		- Pr[A and B] = Pr[A] . Pr[B]
		- 即 A 的发生不会告诉你 B 是否发生的任何信息
	- 在 V 上的随机变量 X 与 Y 是独立的，如果
		- 任意 V 上的元素 a,b
		- 如果 Pr[X=a and Y=b] = Pr[X=a] . Pr[Y=b]
	- 例如：
		- U = {0,1}^2
		- 对 U 里均匀地随机取元素
		- X = lsb(r)
		- Y = msb(r)
		- X 与 Y 是独立的随机变量
		- 一个局部 case：
		- Pr[X=0 and Y=0] = Pr[r=00] = 1/4 = Pr[X=0] . Pr[Y=0]
- XOR 的重要性质：
	- U = {0,1} ^ n
	- Y 是一个随机变量，X 是一个独立的均匀随机变量
	- 则 Z = X XOR Y 也是个均匀随机变量
	- 考虑一个 n = 0 和 Z = 0 的 case
	- Pr[Z=0] = Pr[(x, y) = (0,0) or (x,y) = (1,1)] = Pr[(x, y) = (0,0)] +  Pr[(x,y) = (1,1)]
	- 由于 X 与 Y 是独立的
	- Pr[(x, y) = (0,0)] = p0 / 2
	- Pr[(x,y) = (1,1)] = p1 / 2
	- Pr[Z=0] = (p0 + p1) / 2 = 1 / 2
	- 同理 Pr[Z=1] = 1 / 2
- 生日悖论：
	- 最少需要几人，当中两人同生日的概率会超过一半。
	- 样本 U = 1-365
	- 当 n = 1.2 * (sqrt . size U)
		- Pr[存在 i,j : ri = rj] >= 1 / 2
	- 1.2 * sqrt(365) = 24
-
-
- 对称加密
	- 一个加密算法算法可以由这样的三元组定义 (K, M, C)
		- K 表示 key 的空间，M 表示被加密的消息的空间，C 表示密文的空间
		- 它由两个高效算法 （E，D）组成
		- E: K * M -> C
		- D: K * C -> M
		- 需要满足对于任意的 m 属于 M，k 属于 K
			- D(k, E(k, m)) = m
	- E 通常是一个随机化算法，它的结果可能不确定，D 是确定的
-
- The One Time Pad (OTP)
	- C :=
		- E(k, m) = k xor m
		- D(k, c) = k xor c
	- 可以论证
		- D(k, E(k, m)) = D(k, k xor m) = k xor (k xor m) = (k xor k) xor m = 0 xor m = m
	- OTP 很容易基于 m 与 c 生成 k，k = m xor c
	- OTP 在实践中很难使用的原因是 k 和 m 是一样长的，传输 c 之前需要传输等长的 k，这在实际中很难做到
-
- shannon 关于加密安全性的论述：
	- basic idea： CT 不应该泄露任何关于 PT 的信息
	- 定义：
		- 一个在 (K, M, C) 上的 cipher (E, D) 拥有 perfect secrecy，如果
		- 对任意的 m0, m1 属于 M，len(M0) = len(M1) 以及任意的  c 属于 C
		- Pr[E(k, m0)=c] = Pr[E(k, m)=c]
		- k 是一个在 K 中均匀抽样的随机变量
-
- OTP 拥有 perfect secrecy
	- Pr[E(k, m)=c] = (K 中所有使得 E(k, m) = c 的 k 的数量) /  |K|
	- 如果分子是常量，整个结果就是常量
	- 因为 OTP 的 k = m xor c，是一个常量，所以可以使得 E(k, m) = c 的 k 的数量 只有一个
	- 所以上述等式是常量，OTP 拥有 perfect secrecy，不能仅仅根据 c 去攻击它
	- 但是还存在其他可能的攻击...
- shannon 还证明了
	- perfect secrecy => |K| >= |M|
	- key-len >= len-msg
	- 因此这套系统并不实用
-
- Stream Ciphers：making OTP practical
	- idea: 用伪随机的 key 替换随机的 key
	- PRG: 是一个 function，他把一个较小的 seed space （K） 映射到一个较大的 space （G(k)）
		- 这个函数必须高效，G 本身是确定的，只有种子是随机的，计算结果需要看上去比较“随机”
	- 这种形式下，原本的 OTP 变为了
		- C = E(k, m) := m XOR G(k)
		- D (k, c) :=  c XOR G(k)
	- 因为 stream cipher 的 key 长度小于 message 的长度，所以它肯定没有 perfect secrecy
	- PRG 需要 unpredictable 来保证安全性：
		- predictable 是指一旦知道了 G(k) 的前几位，可以计算出剩余的部分
		- stream cipher 中，如果 PRG 可预测，那么一旦有些先验知识，比如知道密文的前几位，因为有些通信协议里，开头部分是固定的，attcker 可以通过用 XOR 反推出 G(k) 的前几位，进而破解整个 G(k)
	- predictable 的形式化定义：
		- 存在一个有效算法 A
		- 存在某个 i，使得随机在 K 里选取一个 k，算法 A 在接受 G(k) 的前 i 位后，得出一个预测的 result
		- 如果 Pr[result = 真实的 i+1 位值] >= 1/2 + epsilon
		- epsilon 表示一个 “non-negligible” value，它 >= 1 / 2^30
	- 一些 weak 的 PRG：
		- 线性的：
			- r[0] = seed
			- r[i] = (a * r[i-1] +b) mod p
		- glibc random:
			- r[i] = (r[i-3] + r[i-31]) % 2^32
			- output r[i] >> 1
	- epsilon 在学术上有更严格的关于 negligible 和 non-negligible 的定义：
		- epsilon 是一个自然数映射到实数的函数
		- non-neg：
			- 它的值 >= 1 / ploy，对很多入参
		- neg：
			- 存在某个入参，它之后 epsilon 的都小于 ploy
		-
		-
		-
-